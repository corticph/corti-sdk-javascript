// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../BaseClient.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as core from "../../../../core/index.js";
import { handleNonStatusCodeError } from "../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../errors/index.js";
import * as serializers from "../../../../serialization/index.js";
import * as Corti from "../../../index.js";

export declare namespace TranscriptsClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class TranscriptsClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<TranscriptsClient.Options>;

    constructor(options: TranscriptsClient.Options) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * Retrieves a list of transcripts for a given interaction.
     *
     * @param {Corti.TranscriptsListRequest} request
     * @param {TranscriptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Corti.BadRequestError}
     * @throws {@link Corti.UnauthorizedError}
     * @throws {@link Corti.ForbiddenError}
     * @throws {@link Corti.InternalServerError}
     * @throws {@link Corti.GatewayTimeoutError}
     *
     * @example
     *     await client.transcripts.list({
     *         id: "f47ac10b-58cc-4372-a567-0e02b2c3d479"
     *     })
     */
    public list(
        request: Corti.TranscriptsListRequest,
        requestOptions?: TranscriptsClient.RequestOptions,
    ): core.HttpResponsePromise<Corti.TranscriptsListResponse> {
        return core.HttpResponsePromise.fromPromise(this.__list(request, requestOptions));
    }

    private async __list(
        request: Corti.TranscriptsListRequest,
        requestOptions?: TranscriptsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Corti.TranscriptsListResponse>> {
        const { id, full } = request;
        const _queryParams: Record<string, unknown> = {
            full,
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "Tenant-Name": requestOptions?.tenantName ?? this._options?.tenantName }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)).base,
                `interactions/${core.url.encodePathParam(serializers.Uuid.jsonOrThrow(id, { omitUndefined: true }))}/transcripts/`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.TranscriptsListResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Corti.BadRequestError(_response.error.body, _response.rawResponse);
                case 401:
                    throw new Corti.UnauthorizedError(_response.error.body, _response.rawResponse);
                case 403:
                    throw new Corti.ForbiddenError(
                        serializers.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                case 500:
                    throw new Corti.InternalServerError(
                        serializers.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                case 504:
                    throw new Corti.GatewayTimeoutError(
                        serializers.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.CortiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/interactions/{id}/transcripts/",
        );
    }

    /**
     * Create a transcript from an audio file attached, via `/recordings` endpoint, to the interaction.<br/><Note>Each interaction may have more than one audio file and transcript associated with it. While audio files up to 60min in total duration, or 150MB in total size, may be attached to an interaction, synchronous processing is only supported for audio files less than ~2min in duration.<br/><br/>If an audio file takes longer to transcribe than the 25sec synchronous processing timeout, then it will continue to process asynchronously. In this scenario, an incomplete or empty transcript with `status=processing` will be returned with a location header that can be used to retrieve the final transcript.<br/><br/>The client can poll the Get Transcript endpoint (`GET /interactions/{id}/transcripts/{transcriptId}/status`) for transcript status changes:<br/>- `200 OK` with status `processing`, `completed`, or `failed`<br/>- `404 Not Found` if the `interactionId` or `transcriptId` are invalid<br/><br/>The completed transcript can be retrieved via the Get Transcript endpoint (`GET /interactions/{id}/transcripts/{transcriptId}/`).</Note>
     *
     * @param {Corti.TranscriptsCreateRequest} request
     * @param {TranscriptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Corti.BadRequestError}
     * @throws {@link Corti.UnauthorizedError}
     * @throws {@link Corti.ForbiddenError}
     * @throws {@link Corti.InternalServerError}
     * @throws {@link Corti.GatewayTimeoutError}
     *
     * @example
     *     await client.transcripts.create({
     *         id: "f47ac10b-58cc-4372-a567-0e02b2c3d479",
     *         recordingId: "f47ac10b-58cc-4372-a567-0e02b2c3d479",
     *         primaryLanguage: "en"
     *     })
     */
    public create(
        request: Corti.TranscriptsCreateRequest,
        requestOptions?: TranscriptsClient.RequestOptions,
    ): core.HttpResponsePromise<Corti.TranscriptsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
    }

    private async __create(
        request: Corti.TranscriptsCreateRequest,
        requestOptions?: TranscriptsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Corti.TranscriptsResponse>> {
        const { id, ..._body } = request;
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "Tenant-Name": requestOptions?.tenantName ?? this._options?.tenantName }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)).base,
                `interactions/${core.url.encodePathParam(serializers.Uuid.jsonOrThrow(id, { omitUndefined: true }))}/transcripts/`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.TranscriptsCreateRequest.jsonOrThrow(_body, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.TranscriptsResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Corti.BadRequestError(_response.error.body, _response.rawResponse);
                case 401:
                    throw new Corti.UnauthorizedError(_response.error.body, _response.rawResponse);
                case 403:
                    throw new Corti.ForbiddenError(
                        serializers.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                case 500:
                    throw new Corti.InternalServerError(
                        serializers.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                case 504:
                    throw new Corti.GatewayTimeoutError(
                        serializers.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.CortiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/interactions/{id}/transcripts/",
        );
    }

    /**
     * Retrieve a transcript from a specific interaction.<br/><Note>Each interaction may have more than one transcript associated with it. Use the List Transcript request (`GET /interactions/{id}/transcripts/`) to see all transcriptIds available for the interaction.<br/><br/>The client can poll this Get Transcript endpoint (`GET /interactions/{id}/transcripts/{transcriptId}/status`) for transcript status changes:<br/>- `200 OK` with status `processing`, `completed`, or `failed`<br/>- `404 Not Found` if the `interactionId` or `transcriptId` are invalid<br/><br/>Status of `completed` indicates the transcript is finalized. If the transcript is retrieved while status is `processing`, then it will be incomplete.</Note>
     *
     * @param {Corti.TranscriptsGetRequest} request
     * @param {TranscriptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Corti.BadRequestError}
     * @throws {@link Corti.UnauthorizedError}
     * @throws {@link Corti.ForbiddenError}
     * @throws {@link Corti.InternalServerError}
     * @throws {@link Corti.GatewayTimeoutError}
     *
     * @example
     *     await client.transcripts.get({
     *         id: "f47ac10b-58cc-4372-a567-0e02b2c3d479",
     *         transcriptId: "f47ac10b-58cc-4372-a567-0e02b2c3d479"
     *     })
     */
    public get(
        request: Corti.TranscriptsGetRequest,
        requestOptions?: TranscriptsClient.RequestOptions,
    ): core.HttpResponsePromise<Corti.TranscriptsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__get(request, requestOptions));
    }

    private async __get(
        request: Corti.TranscriptsGetRequest,
        requestOptions?: TranscriptsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Corti.TranscriptsResponse>> {
        const { id, transcriptId } = request;
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "Tenant-Name": requestOptions?.tenantName ?? this._options?.tenantName }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)).base,
                `interactions/${core.url.encodePathParam(serializers.Uuid.jsonOrThrow(id, { omitUndefined: true }))}/transcripts/${core.url.encodePathParam(serializers.Uuid.jsonOrThrow(transcriptId, { omitUndefined: true }))}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.TranscriptsResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Corti.BadRequestError(_response.error.body, _response.rawResponse);
                case 401:
                    throw new Corti.UnauthorizedError(_response.error.body, _response.rawResponse);
                case 403:
                    throw new Corti.ForbiddenError(
                        serializers.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                case 500:
                    throw new Corti.InternalServerError(
                        serializers.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                case 504:
                    throw new Corti.GatewayTimeoutError(
                        serializers.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.CortiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/interactions/{id}/transcripts/{transcriptId}",
        );
    }

    /**
     * Deletes a specific transcript associated with an interaction.
     *
     * @param {Corti.TranscriptsDeleteRequest} request
     * @param {TranscriptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Corti.BadRequestError}
     * @throws {@link Corti.UnauthorizedError}
     * @throws {@link Corti.ForbiddenError}
     * @throws {@link Corti.InternalServerError}
     * @throws {@link Corti.GatewayTimeoutError}
     *
     * @example
     *     await client.transcripts.delete({
     *         id: "f47ac10b-58cc-4372-a567-0e02b2c3d479",
     *         transcriptId: "f47ac10b-58cc-4372-a567-0e02b2c3d479"
     *     })
     */
    public delete(
        request: Corti.TranscriptsDeleteRequest,
        requestOptions?: TranscriptsClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__delete(request, requestOptions));
    }

    private async __delete(
        request: Corti.TranscriptsDeleteRequest,
        requestOptions?: TranscriptsClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const { id, transcriptId } = request;
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "Tenant-Name": requestOptions?.tenantName ?? this._options?.tenantName }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)).base,
                `interactions/${core.url.encodePathParam(serializers.Uuid.jsonOrThrow(id, { omitUndefined: true }))}/transcripts/${core.url.encodePathParam(serializers.Uuid.jsonOrThrow(transcriptId, { omitUndefined: true }))}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Corti.BadRequestError(_response.error.body, _response.rawResponse);
                case 401:
                    throw new Corti.UnauthorizedError(_response.error.body, _response.rawResponse);
                case 403:
                    throw new Corti.ForbiddenError(
                        serializers.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                case 500:
                    throw new Corti.InternalServerError(
                        serializers.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                case 504:
                    throw new Corti.GatewayTimeoutError(
                        serializers.ErrorResponse.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        _response.rawResponse,
                    );
                default:
                    throw new errors.CortiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "DELETE",
            "/interactions/{id}/transcripts/{transcriptId}",
        );
    }

    /**
     * Poll for transcript creation status.<br/><Note>Status of `completed` indicates the transcript is finalized.<br/>If the transcript is retrieved while status is `processing`, then it will be incomplete.<br/>Status of `failed` indicate the transcript was not created successfully; please retry.</Note>
     *
     * @param {Corti.TranscriptsGetStatusRequest} request
     * @param {TranscriptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Corti.NotFoundError}
     *
     * @example
     *     await client.transcripts.getStatus({
     *         id: "f47ac10b-58cc-4372-a567-0e02b2c3d479",
     *         transcriptId: "f47ac10b-58cc-4372-a567-0e02b2c3d479"
     *     })
     */
    public getStatus(
        request: Corti.TranscriptsGetStatusRequest,
        requestOptions?: TranscriptsClient.RequestOptions,
    ): core.HttpResponsePromise<Corti.TranscriptsStatusResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getStatus(request, requestOptions));
    }

    private async __getStatus(
        request: Corti.TranscriptsGetStatusRequest,
        requestOptions?: TranscriptsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Corti.TranscriptsStatusResponse>> {
        const { id, transcriptId } = request;
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "Tenant-Name": requestOptions?.tenantName ?? this._options?.tenantName }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)).base,
                `interactions/${core.url.encodePathParam(serializers.Uuid.jsonOrThrow(id, { omitUndefined: true }))}/transcripts/${core.url.encodePathParam(serializers.Uuid.jsonOrThrow(transcriptId, { omitUndefined: true }))}/status`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.TranscriptsStatusResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Corti.NotFoundError(_response.error.body, _response.rawResponse);
                default:
                    throw new errors.CortiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/interactions/{id}/transcripts/{transcriptId}/status",
        );
    }
}
